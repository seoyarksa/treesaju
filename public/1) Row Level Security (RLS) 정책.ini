1) Row Level Security (RLS) 정책
profiles 테이블

profiles_select_own (SELECT, authenticated)
로그인한 사용자는 자기 프로필(user_id=auth.uid())만 조회할 수 있어요.
→ 일반 유저가 다른 사람 프로필을 못 보게 함.

profiles_update_own (UPDATE, authenticated)
로그인한 사용자는 자기 프로필만 수정할 수 있어요.
→ 닉네임/전화 등 소유자 필드 갱신 가능, 남의 프로필 수정 불가.

profiles_admin_ (SELECT/UPDATE/DELETE, authenticated + is_admin)*
is_admin(auth.uid())가 true인 경우 모든 프로필에 대해 조회/수정/삭제 가능.
→ 관리자 페이지(회원관리)에서 전체 관리하는 권한.

allow service role to update profiles (UPDATE, service_role)
서버 환경키(서비스 롤)로 동작하는 백엔드는 RLS 통과하여 어떤 행이든 업데이트 가능.
→ Cron/웹훅/서버 API가 안전하게 시스템 갱신(예: 결제 동기화) 가능.

profiles_rpc_select / profiles_rpc_update (public)
특정 RPC 수행 시만 열어주던 임시 정책(예: 카운터 RPC에서 설정 플래그로 제한적으로 허용) 용도로 남아 있던 정책입니다.
→ 지금은 일반 화면에서 필요 없고, RPC로만 쓰도록 범위가 매우 좁게 잡혀 있어 영향은 제한적입니다. (혼동되면 나중에 정리해도 됨)

memberships 테이블

memberships_select_own (SELECT, authenticated)
로그인한 사용자는 자기 구독 행만 조회 가능.
→ 마이페이지에서 “내 구독 상태” 보기.

(업데이트/인서트/삭제는 서비스 롤 또는 서버 트리거 경로로만 하게 두는 운영이 일반적입니다.)

2) 인덱스/제약 (Constraints & Indexes)

uniq_profiles_phone_verified (부분 유니크 인덱스)
phone_verified is true AND phone not null/not empty 인 행만 전화번호 유니크 강제.
→ 같은 번호를 여러 계정에 넣을 수는 있지만, ‘인증 성공’된 번호는 단 한 계정만 가질 수 있음.
→ 전화인증 시 “이미 존재하는 번호입니다” 메시지를 정확히 띄울 수 있게 도와줌.

idx_memberships_one_active_per_user (부분 유니크 인덱스)
status='active' 조건에서만 user_id 유니크.
→ 한 사용자는 동시에 활성 구독 1건만 유지(취소·이력 행은 자유롭게 존재).
→ 이전에 memberships_user_id_key(무조건 유저당 1행) 때문에 이력 관리가 답답했는데, 그 제약을 드롭하고 이 “부분 유니크”로 바꿔 운영 친화적으로 바꿈.

3) 트리거/함수 흐름 (동기화 자동화)

auth.users → profiles 자동 생성 (handle_new_user 트리거)
새 유저가 가입되면 profiles에 자동으로 1:1 행 생성(표시명/전화 간단 채움).
→ “프로필이 없어 생기는 오류” 예방.

auth.users 업데이트 → profiles 동기화 (handle_user_update 트리거)
전화가 추가/수정되면 프로필 전화/인증 플래그 동기화. 최초 인증 시 30일 트라이얼 기간 필드 기록.
→ OTP 인증 흐름과 자연스럽게 연동.

memberships 변경 → profiles 등급 재계산 (trigger_refresh_grade + refresh_profile_grade/compute_grade)
멤버십이 active이고 유효기간 내면 프로필 등급을 basic/regular/special로 반영.
→ 결제 완료/취소/만료 시 프로필.grade가 자동으로 맞춰짐.
(어제는 grade↔role도 맞추자고 했지만, 현재 설계의 기준은 표시는 grade, 관리 권한은 별도의 role 또는 is_admin()으로 구분이 깔끔합니다.)

4) 카운트/한도(사용량) 관련

과거에는 can_render_and_count() RPC에서 등급 조건에 따라 일일 한도/카운터를 갱신하도록 설계해 두었습니다.
지금은 “등급별 기본 한도(예: basic 20회/일, premium 60→100 등)”를 명확히 고정하고, 결제/등급변경 시 UI에 표시되는 daily_limit을 서버에서 함께 갱신하는 방식으로 단순화하는 걸 권장드립니다.
→ 운영 난이도↓, 예측 가능성↑
(원하시면 이 부분은 완전 고정 규칙으로 함수 내용을 더 간소화할 수 있어요.)

5) 왜 이런 구조인가? (운영 관점의 효과)

보안: 사용자 본인만 자신의 행을 보고/수정, 관리자는 전체 접근, 서버는 서비스 롤을 통해 안전하게 우회 ⇒ 예측 가능한 권한 모델.

전화 인증 실무 대응: 인증 전엔 중복 허용, 인증 후엔 충돌 방지 ⇒ “번호 도용/중복” 실수 줄임.

구독 이력 관리: 부분 유니크로 활성 1건만 묶고 이력은 남김 ⇒ 결제 로직/정산 편의성.

자동 동기화: 가입, 전화 인증, 구독 변경 시 사람 손없이 프로필이 최신 상태로 유지.

6) 운영 체크리스트 (지금 상태 확인용)

내 계정으로 로그인 → /profiles 선택/업데이트 테스트

내 프로필만 보이고 수정되는지.

관리자 계정에서 전체 프로필 조회/수정 가능 여부

is_admin()이 true로 동작하는지.

전화 인증 플로우

인증 성공 시 다른 계정에 같은 번호가 인증되어 있으면 **“이미 존재하는 번호입니다”**가 뜨는지.

결제 성공 후 memberships 갱신 → profiles.grade 자동 반영

active + 기간 유효 시 grade 올라가고, 취소/만료 시 기본으로 복귀하는지.

memberships 중복 활성 방지

같은 유저에 status='active' 두 건 생성 시도하면 막히는지.

서비스 롤로 서버에서 profiles 업데이트가 문제없이 되는지.